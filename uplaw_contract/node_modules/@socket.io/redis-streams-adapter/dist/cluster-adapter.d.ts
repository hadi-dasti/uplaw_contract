import { Adapter, BroadcastOptions, Room } from "socket.io-adapter";
export interface ClusterAdapterOptions {
    /**
     * The number of ms between two heartbeats.
     * @default 5_000
     */
    heartbeatInterval?: number;
    /**
     * The number of ms without heartbeat before we consider a node down.
     * @default 10_000
     */
    heartbeatTimeout?: number;
}
export declare enum MessageType {
    INITIAL_HEARTBEAT = 1,
    HEARTBEAT = 2,
    BROADCAST = 3,
    SOCKETS_JOIN = 4,
    SOCKETS_LEAVE = 5,
    DISCONNECT_SOCKETS = 6,
    FETCH_SOCKETS = 7,
    FETCH_SOCKETS_RESPONSE = 8,
    SERVER_SIDE_EMIT = 9,
    SERVER_SIDE_EMIT_RESPONSE = 10,
    BROADCAST_CLIENT_COUNT = 11,
    BROADCAST_ACK = 12
}
export interface ClusterMessage {
    uid: string;
    nsp: string;
    type: MessageType;
    data?: Record<string, unknown>;
}
export declare abstract class ClusterAdapter extends Adapter {
    #private;
    protected constructor(nsp: any, opts: Required<ClusterAdapterOptions>);
    protected initHeartbeat(): void;
    close(): Promise<void> | void;
    onMessage(message: ClusterMessage, offset: string): Promise<any>;
    broadcast(packet: any, opts: BroadcastOptions): Promise<any>;
    broadcastWithAck(packet: any, opts: BroadcastOptions, clientCountCallback: (clientCount: number) => void, ack: (...args: any[]) => void): void;
    serverCount(): Promise<number>;
    /**
     *
     * @param opts
     * @param rooms
     */
    addSockets(opts: BroadcastOptions, rooms: Room[]): void;
    delSockets(opts: BroadcastOptions, rooms: Room[]): void;
    disconnectSockets(opts: BroadcastOptions, close: boolean): void;
    fetchSockets(opts: BroadcastOptions): Promise<any[]>;
    serverSideEmit(packet: any[]): any;
    abstract doPublish(message: ClusterMessage): Promise<string>;
}
